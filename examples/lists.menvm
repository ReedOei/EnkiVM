position main
goto

:length

position cons_case
gotochoice

:empty_case # L Arg
int 0
str empty
functor
unify
int 0
unify
goto

:cons_case # L Arg
fresh # L Arg X
fresh # L Arg X Y
dup # L Arg X Y Y
rot # L Arg Y X Y
swap
int 2
str cons
functor # L Arg Y cons(X,Y)
rot # L cons(X,Y) Arg Y
rot # L Y cons(X,Y) Arg
unify # L Y
fresh # L Y NewL
dup # L Y NewL NewL
rot # L NewL Y NewL
swap # L NewL NewL Y
position after_rec_length_call # L NewL NewL Y Pos
rot # L NewL Pos NewL Y
position length
goto # After call: L NewL
:after_rec_length_call
int 1 # L NewL 1
add # L (NewL + 1)
unify # ReturnPos
goto # Return

:main
# Build the list: [90,28,14,12]
int 0
str empty
functor
int 12
int 2
str cons
functor
int 14
int 2
str cons
functor
int 28
int 2
str cons
functor
int 90
int 2
str cons
functor # [90,28,14,12]
position aftercall # [90,28,14,12] :aftercall
swap # :aftercall [90,28,14,12]
var L # :aftercall [90,28,14,12] L
swap # :aftercall L [90,28,14,12]
position length # :aftercall L [90,28,14,12] :length
goto
:aftercall
var L
print

